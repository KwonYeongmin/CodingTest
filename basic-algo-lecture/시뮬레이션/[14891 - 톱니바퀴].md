```cpp
#include <iostream>
#include <vector>
#include <memory.h>
#include <cmath>

using namespace std;
// 톱니바퀴 A를 회전할 때, 그 옆에 있는 톱니바퀴 B와 서로 맞닿은 톱니의 극이 다르다면,
// B는 A가 회전한 방향과 반대방향으로 회전하게 된다.
// N극은 0, S극은 1로 나타나있다.
// 총 K번 회전시킨 이후에 네 톱니바퀴의 점수의 합
// 1인 경우는 시계 방향이고, -1인 경우는 반시계 방향
/*
1번 톱니바퀴의 12시방향이 N극이면 0점, S극이면 1점
2번 톱니바퀴의 12시방향이 N극이면 0점, S극이면 2점
3번 톱니바퀴의 12시방향이 N극이면 0점, S극이면 4점
4번 톱니바퀴의 12시방향이 N극이면 0점, S극이면 8점
*/

const int WHEE_COUNT = 4;
const int WHEEL_TEETHNUM = 8;
const int RIGHT_DIRECTION = 2;
const int LEFT_DIRECTION = 6;

struct Wheel
{
    Wheel() 
    { 
        memset(teeth, 0, WHEEL_TEETHNUM);
    };
    Wheel(string temp) 
    {
        for (int i = 0; i < WHEEL_TEETHNUM; ++i)
        {
            teeth[i] = temp[i] - '0';
        }
    }
    void Print() 
    {
        for (int i = 0; i < WHEEL_TEETHNUM;++i)
        {
            cout << teeth[i] << ' ';
        }
        cout << '\n';
    }
    // 12시방향부터 시계방향 순서대로
    int teeth[WHEEL_TEETHNUM];
};

struct RotationCase
{
    RotationCase() :wheelNumber(0), direction(0) {}
    RotationCase(int _wheelNum,int _direction) :wheelNumber(_wheelNum), direction(_direction) {  }
    int wheelNumber;
    int direction;
};

vector<Wheel> wheels;
bool visited[4];
int K;

void Rotate(int wheelIndex, int dir)
{
    // 시계 방향
    if (dir == 1)
    {
        int lastValue = wheels[wheelIndex].teeth[WHEEL_TEETHNUM -1];
    
        for (int i = WHEEL_TEETHNUM - 1; i > 0; --i)
        {
            wheels[wheelIndex].teeth[i] = wheels[wheelIndex].teeth[i-1];
        }
        wheels[wheelIndex].teeth[0] = lastValue;
    }
    // 시계반대방향
    else if (dir == -1) 
    {
        int firstValue = wheels[wheelIndex].teeth[0];

        for (int i = 0; i < WHEEL_TEETHNUM - 1; ++i)
        {
            wheels[wheelIndex].teeth[i] = wheels[wheelIndex].teeth[i + 1];
        }
        wheels[wheelIndex].teeth[WHEEL_TEETHNUM - 1] = firstValue;
    }
}

void Update(int wheelIndex, int dir) 
{
    if (wheelIndex < 0 || wheelIndex >= WHEE_COUNT)
    {
        return;
    }

    if (visited[wheelIndex])
    {
        return;
    }

    visited[wheelIndex] = true;

    // 방문 처리
    // cout << "[" << wheelIndex << "]" << " 번째 톱니바퀴의 방문==\n";
    if (wheelIndex > 0 && wheels[wheelIndex].teeth[LEFT_DIRECTION] != wheels[wheelIndex - 1].teeth[RIGHT_DIRECTION])
    {
        Update(wheelIndex - 1, -dir);
    }

    if (wheelIndex < WHEE_COUNT - 1 && wheels[wheelIndex].teeth[RIGHT_DIRECTION] != wheels[wheelIndex + 1].teeth[LEFT_DIRECTION])
    {
        Update(wheelIndex + 1, -dir);
    }

    // 현재 톱니바퀴 회전
    Rotate(wheelIndex, dir);
}

int main() 
{
    for (int i = 0; i < WHEE_COUNT; ++i)
    {
        string temp;
        cin >> temp;
        wheels.push_back(Wheel(temp));
    }

    cin >> K;
    vector<RotationCase> cases(K,RotationCase());

    for (int i = 0; i < K; ++i)
    {
        cin >> cases[i].wheelNumber >> cases[i].direction;
    }

    for (int i = 0; i < K; ++i) 
    {
        memset(visited, false, WHEE_COUNT);
        Update(cases[i].wheelNumber - 1, cases[i].direction);
    }

    int score = 0;

    for (int i = 0; i < WHEE_COUNT; ++i)
    {
        if (0 != wheels[i].teeth[0])
        {
            score += pow(2, i);
        }
    }

    cout << score;

    return 0;
}
```
