## DFS 풀이
```cpp
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

struct Node
{
    int x, y;
    Node() : x(0), y(0) {}
    Node(int _x, int _y) : x(_x), y(_y) {}
};

int N;
char board[102][102];

// DFS로 영역을 탐색하는 함수
bool dfs(int x, int y, char color, vector<vector<bool>>& visited)
{
    if (x < 0 || y < 0 || x >= N || y >= N)
    {
        return false;
    }

    if (visited[x][y] || board[x][y] != color)
    {
        return false;
    }

    visited[x][y] = true;
    
    // 상하좌우 탐색
    dfs(x - 1, y, color, visited);
    dfs(x + 1, y, color, visited);
    dfs(x, y - 1, color, visited);
    dfs(x, y + 1, color, visited);
    
    return true;
}

int countAreas(vector<vector<bool>>& visited)
{
    int count = 0;

    // 구역의 개수를 세는 부분
    for (int i = 0; i < N; ++i)
    {
        for (int j = 0; j < N; ++j)
        {
            if (!visited[i][j])
            {
                if (dfs(i, j, board[i][j], visited))
                {
                    ++count;
                }
            }
        }
    }
    
    return count;
}

int main()
{
    cin >> N;

    // 미로 입력
    for (int i = 0; i < N; ++i)
    {
        for (int j = 0; j < N; ++j)
        {
            cin >> board[i][j];
        }
    }

    // 적록색약이 아닌 경우
    vector<vector<bool>> visited1(N, vector<bool>(N, false));
    int res1 = countAreas(visited1);

    // 적록색약인 경우, R을 G로 바꿔서 처리
    for (int i = 0; i < N; ++i)
    {
        for (int j = 0; j < N; ++j)
        {
            if (board[i][j] == 'R')
            {
                board[i][j] = 'G';
            }
        }
    }

    vector<vector<bool>> visited2(N, vector<bool>(N, false));
    int res2 = countAreas(visited2);

    cout << res1 << " " << res2 << '\n';

    return 0;
}

```
